import { BooleanInputSimple } from "components/Inputs/BooleanInput/BooleanInputSimple";
import { CSSUnitInputSimple } from "components/Inputs/CSSUnitInput/CSSUnitInputSimple";
import { NamedListInputSimple } from "components/Inputs/ListInput/NamedListInputSimple";
import { DropdownSelect } from "components/Inputs/OptionsDropdown/DropdownSelect";
import { RadioInputsSimple } from "components/Inputs/RadioInputs/RadioInputsSimple";
import { match } from "ts-pattern";

import type { FieldEntryUnion, KnownInputFieldTypes } from "../inputFieldTypes";

import { NumberInput } from "./NumberInput";
import { StringInput } from "./StringInput";

/**
 * Due to dynamics of types the on change callback is a very general purpose
 * function that can take any of our input types as arguments. Type narrowing is
 * not really beneficial here since we already know the type and the callback is
 * generated by the code not provided by the user.
 */
export type OnChangeCallback = (newValue: KnownInputFieldTypes) => void;

export type SettingsInputElementProps = FieldEntryUnion & {
  id: string;
  onChange: OnChangeCallback;
};

export function SettingsInputElement(args: SettingsInputElementProps) {
  return match(args)
    .with({ inputType: "string" }, (x) => <StringInput {...x} />)
    .with({ inputType: "number" }, (x) => <NumberInput {...x} />)
    .with({ inputType: "cssMeasure" }, (x) => <CSSUnitInputSimple {...x} />)
    .with({ inputType: "boolean" }, (x) => <BooleanInputSimple {...x} />)
    .with({ inputType: "list" }, (x) => <NamedListInputSimple {...x} />)
    .with({ inputType: "dropdown" }, (x) => <DropdownSelect {...x} />)
    .with({ inputType: "radio" }, (x) => <RadioInputsSimple {...x} />)
    .otherwise(({ inputType }) => (
      <div>
        I don't know how to render the input of type {inputType} yet! Sorry.
      </div>
    ));
}
